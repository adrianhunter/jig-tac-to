/* src/lib/VirtualList.svelte generated by Svelte v3.18.1 */
import { SvelteComponentDev, add_location, add_render_callback, add_resize_listener, append_dev, binding_callbacks, check_outros, create_slot, detach_dev, dispatch_dev, element, get_slot_changes, get_slot_context, group_outros, init, insert_dev, listen_dev, outro_and_destroy_block, safe_not_equal, set_custom_element_data, set_style, space, text, transition_in, transition_out, update_keyed_each, validate_each_keys } from "/web_modules/svelte/internal.js";
import { onMount, tick } from "/web_modules/svelte.js";
const file = "src/lib/VirtualList.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-3f07ig-style";
  style.textContent = "svelte-virtual-list-viewport.svelte-3f07ig{position:relative;overflow-y:auto;-webkit-overflow-scrolling:touch;display:block}svelte-virtual-list-contents.svelte-3f07ig,svelte-virtual-list-row.svelte-3f07ig{display:block}svelte-virtual-list-row.svelte-3f07ig{overflow:hidden}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiVmlydHVhbExpc3Quc3ZlbHRlIiwic291cmNlcyI6WyJWaXJ0dWFsTGlzdC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5pbXBvcnQgeyBvbk1vdW50LCB0aWNrIH0gZnJvbSAnc3ZlbHRlJztcbmV4cG9ydCBsZXQgaXRlbXM7XG5leHBvcnQgbGV0IGhlaWdodCA9ICcxMDAlJztcbmV4cG9ydCBsZXQgaXRlbUhlaWdodCA9IHVuZGVmaW5lZDtcbmxldCBmb287XG4vLyByZWFkLW9ubHksIGJ1dCB2aXNpYmxlIHRvIGNvbnN1bWVycyB2aWEgYmluZDpzdGFydFxuZXhwb3J0IGxldCBzdGFydCA9IDA7XG5leHBvcnQgbGV0IGVuZCA9IDA7XG4vLyBsb2NhbCBzdGF0ZVxubGV0IGhlaWdodF9tYXAgPSBbXTtcbmxldCByb3dzO1xubGV0IHZpZXdwb3J0O1xubGV0IGNvbnRlbnRzO1xubGV0IHZpZXdwb3J0X2hlaWdodCA9IDA7XG5sZXQgdmlzaWJsZTtcbmxldCBtb3VudGVkO1xubGV0IHRvcCA9IDA7XG5sZXQgYm90dG9tID0gMDtcbmxldCBhdmVyYWdlX2hlaWdodDtcbiQ6IHZpc2libGUgPSBpdGVtcy5zbGljZShzdGFydCwgZW5kKS5tYXAoKGRhdGEsIGkpPT57XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5kZXg6IGkgKyBzdGFydCxcbiAgICAgICAgZGF0YVxuICAgIH07XG59KTtcbi8vIHdoZW5ldmVyIGBpdGVtc2AgY2hhbmdlcywgaW52YWxpZGF0ZSB0aGUgY3VycmVudCBoZWlnaHRtYXBcbiQ6IGlmIChtb3VudGVkKSByZWZyZXNoKGl0ZW1zLCB2aWV3cG9ydF9oZWlnaHQsIGl0ZW1IZWlnaHQpO1xuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaChpdGVtczEsIHZpZXdwb3J0X2hlaWdodDEsIGl0ZW1IZWlnaHQxKSB7XG4gICAgY29uc3QgeyBzY3JvbGxUb3AgIH0gPSB2aWV3cG9ydDtcbiAgICBhd2FpdCB0aWNrKCk7IC8vIHdhaXQgdW50aWwgdGhlIERPTSBpcyB1cCB0byBkYXRlXG4gICAgbGV0IGNvbnRlbnRfaGVpZ2h0ID0gdG9wIC0gc2Nyb2xsVG9wO1xuICAgIGxldCBpID0gc3RhcnQ7XG4gICAgd2hpbGUoY29udGVudF9oZWlnaHQgPCB2aWV3cG9ydF9oZWlnaHQxICYmIGkgPCBpdGVtczEubGVuZ3RoKXtcbiAgICAgICAgbGV0IHJvdyA9IHJvd3NbaSAtIHN0YXJ0XTtcbiAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgIGVuZCA9IGkgKyAxO1xuICAgICAgICAgICAgYXdhaXQgdGljaygpOyAvLyByZW5kZXIgdGhlIG5ld2x5IHZpc2libGUgcm93XG4gICAgICAgICAgICByb3cgPSByb3dzW2kgLSBzdGFydF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgcm93X2hlaWdodCA9IGhlaWdodF9tYXBbaV0gPSBpdGVtSGVpZ2h0MSB8fCByb3cub2Zmc2V0SGVpZ2h0O1xuICAgICAgICBjb250ZW50X2hlaWdodCArPSByb3dfaGVpZ2h0O1xuICAgICAgICBpICs9IDE7XG4gICAgfVxuICAgIGVuZCA9IGk7XG4gICAgY29uc3QgcmVtYWluaW5nID0gaXRlbXMxLmxlbmd0aCAtIGVuZDtcbiAgICBhdmVyYWdlX2hlaWdodCA9ICh0b3AgKyBjb250ZW50X2hlaWdodCkgLyBlbmQ7XG4gICAgYm90dG9tID0gcmVtYWluaW5nICogYXZlcmFnZV9oZWlnaHQ7XG4gICAgaGVpZ2h0X21hcC5sZW5ndGggPSBpdGVtczEubGVuZ3RoO1xufVxuYXN5bmMgZnVuY3Rpb24gaGFuZGxlX3Njcm9sbCgpIHtcbiAgICBjb25zdCB7IHNjcm9sbFRvcCAgfSA9IHZpZXdwb3J0O1xuICAgIGNvbnN0IG9sZF9zdGFydCA9IHN0YXJ0O1xuICAgIGZvcihsZXQgdiA9IDA7IHYgPCByb3dzLmxlbmd0aDsgdiArPSAxKXtcbiAgICAgICAgaGVpZ2h0X21hcFtzdGFydCArIHZdID0gaXRlbUhlaWdodCB8fCByb3dzW3ZdLm9mZnNldEhlaWdodDtcbiAgICB9XG4gICAgbGV0IGkgPSAwO1xuICAgIGxldCB5ID0gMDtcbiAgICB3aGlsZShpIDwgaXRlbXMubGVuZ3RoKXtcbiAgICAgICAgY29uc3Qgcm93X2hlaWdodCA9IGhlaWdodF9tYXBbaV0gfHwgYXZlcmFnZV9oZWlnaHQ7XG4gICAgICAgIGlmICh5ICsgcm93X2hlaWdodCA+IHNjcm9sbFRvcCkge1xuICAgICAgICAgICAgc3RhcnQgPSBpO1xuICAgICAgICAgICAgdG9wID0geTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHkgKz0gcm93X2hlaWdodDtcbiAgICAgICAgaSArPSAxO1xuICAgIH1cbiAgICB3aGlsZShpIDwgaXRlbXMubGVuZ3RoKXtcbiAgICAgICAgeSArPSBoZWlnaHRfbWFwW2ldIHx8IGF2ZXJhZ2VfaGVpZ2h0O1xuICAgICAgICBpICs9IDE7XG4gICAgICAgIGlmICh5ID4gc2Nyb2xsVG9wICsgdmlld3BvcnRfaGVpZ2h0KSBicmVhaztcbiAgICB9XG4gICAgZW5kID0gaTtcbiAgICBjb25zdCByZW1haW5pbmcgPSBpdGVtcy5sZW5ndGggLSBlbmQ7XG4gICAgYXZlcmFnZV9oZWlnaHQgPSB5IC8gZW5kO1xuICAgIHdoaWxlKGkgPCBpdGVtcy5sZW5ndGgpaGVpZ2h0X21hcFtpKytdID0gYXZlcmFnZV9oZWlnaHQ7XG4gICAgYm90dG9tID0gcmVtYWluaW5nICogYXZlcmFnZV9oZWlnaHQ7XG4gICAgLy8gcHJldmVudCBqdW1waW5nIGlmIHdlIHNjcm9sbGVkIHVwIGludG8gdW5rbm93biB0ZXJyaXRvcnlcbiAgICBpZiAoc3RhcnQgPCBvbGRfc3RhcnQpIHtcbiAgICAgICAgYXdhaXQgdGljaygpO1xuICAgICAgICBsZXQgZXhwZWN0ZWRfaGVpZ2h0ID0gMDtcbiAgICAgICAgbGV0IGFjdHVhbF9oZWlnaHQgPSAwO1xuICAgICAgICBmb3IobGV0IGkxID0gc3RhcnQ7IGkxIDwgb2xkX3N0YXJ0OyBpMSArPSAxKXtcbiAgICAgICAgICAgIGlmIChyb3dzW2kxIC0gc3RhcnRdKSB7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRfaGVpZ2h0ICs9IGhlaWdodF9tYXBbaTFdO1xuICAgICAgICAgICAgICAgIGFjdHVhbF9oZWlnaHQgKz0gaXRlbUhlaWdodCB8fCByb3dzW2kxIC0gc3RhcnRdLm9mZnNldEhlaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkID0gYWN0dWFsX2hlaWdodCAtIGV4cGVjdGVkX2hlaWdodDtcbiAgICAgICAgdmlld3BvcnQuc2Nyb2xsVG8oMCwgc2Nyb2xsVG9wICsgZCk7XG4gICAgfVxufVxuLy8gdHJpZ2dlciBpbml0aWFsIHJlZnJlc2hcbm9uTW91bnQoKCk9PntcbiAgICByb3dzID0gY29udGVudHMuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3N2ZWx0ZS12aXJ0dWFsLWxpc3Qtcm93Jyk7XG4gICAgbW91bnRlZCA9IHRydWU7XG59KTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIHN2ZWx0ZS12aXJ0dWFsLWxpc3Qtdmlld3BvcnQge1xuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcbiAgICBvdmVyZmxvdy15OiBhdXRvO1xuICAgIC13ZWJraXQtb3ZlcmZsb3ctc2Nyb2xsaW5nOiB0b3VjaDtcbiAgICBkaXNwbGF5OiBibG9jaztcbiAgfVxuICBzdmVsdGUtdmlydHVhbC1saXN0LWNvbnRlbnRzLFxuICBzdmVsdGUtdmlydHVhbC1saXN0LXJvdyB7XG4gICAgZGlzcGxheTogYmxvY2s7XG4gIH1cbiAgc3ZlbHRlLXZpcnR1YWwtbGlzdC1yb3cge1xuICAgIG92ZXJmbG93OiBoaWRkZW47XG4gIH1cbjwvc3R5bGU+XG5cbjxzdmVsdGUtdmlydHVhbC1saXN0LXZpZXdwb3J0XG4gIGJpbmQ6dGhpcz17dmlld3BvcnR9XG4gIGJpbmQ6b2Zmc2V0SGVpZ2h0PXt2aWV3cG9ydF9oZWlnaHR9XG4gIG9uOnNjcm9sbD17aGFuZGxlX3Njcm9sbH1cbiAgc3R5bGU9XCJoZWlnaHQ6IHtoZWlnaHR9O1wiPlxuICA8c3ZlbHRlLXZpcnR1YWwtbGlzdC1jb250ZW50c1xuICAgIGJpbmQ6dGhpcz17Y29udGVudHN9XG4gICAgc3R5bGU9XCJwYWRkaW5nLXRvcDoge3RvcH1weDsgcGFkZGluZy1ib3R0b206IHtib3R0b219cHg7XCI+XG4gICAgeyNlYWNoIHZpc2libGUgYXMgcm93IChyb3cuaW5kZXgpfVxuICAgICAgPHN2ZWx0ZS12aXJ0dWFsLWxpc3Qtcm93PlxuICAgICAgICA8c2xvdCBpdGVtPXtyb3cuZGF0YX0+TWlzc2luZyB0ZW1wbGF0ZTwvc2xvdD5cbiAgICAgIDwvc3ZlbHRlLXZpcnR1YWwtbGlzdC1yb3c+XG4gICAgey9lYWNofVxuICA8L3N2ZWx0ZS12aXJ0dWFsLWxpc3QtY29udGVudHM+XG48L3N2ZWx0ZS12aXJ0dWFsLWxpc3Qtdmlld3BvcnQ+XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBb0dFLDRCQUE0QixjQUFDLENBQUMsQUFDNUIsUUFBUSxDQUFFLFFBQVEsQ0FDbEIsVUFBVSxDQUFFLElBQUksQ0FDaEIsMEJBQTBCLENBQUUsS0FBSyxDQUNqQyxPQUFPLENBQUUsS0FBSyxBQUNoQixDQUFDLEFBQ0QsMENBQTRCLENBQzVCLHVCQUF1QixjQUFDLENBQUMsQUFDdkIsT0FBTyxDQUFFLEtBQUssQUFDaEIsQ0FBQyxBQUNELHVCQUF1QixjQUFDLENBQUMsQUFDdkIsUUFBUSxDQUFFLE1BQU0sQUFDbEIsQ0FBQyJ9 */";
  append_dev(document.head, style);
}

const get_default_slot_changes = dirty => ({
  item: dirty &
  /*visible*/
  16
});

const get_default_slot_context = ctx => ({
  item:
  /*row*/
  ctx[23].data
});

function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
} // (124:4) {#each visible as row (row.index)}


function create_each_block(key_1, ctx) {
  let svelte_virtual_list_row;
  let t0;
  let t1;
  let current;
  const default_slot_template =
  /*$$slots*/
  ctx[19].default;
  const default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[18], get_default_slot_context);
  const block = {
    key: key_1,
    first: null,
    c: function create() {
      svelte_virtual_list_row = element("svelte-virtual-list-row");

      if (!default_slot) {
        t0 = text("Missing template");
      }

      if (default_slot) default_slot.c();
      t1 = space();
      set_custom_element_data(svelte_virtual_list_row, "class", "svelte-3f07ig");
      add_location(svelte_virtual_list_row, file, 124, 6, 3556);
      this.first = svelte_virtual_list_row;
    },
    m: function mount(target, anchor) {
      insert_dev(target, svelte_virtual_list_row, anchor);

      if (!default_slot) {
        append_dev(svelte_virtual_list_row, t0);
      }

      if (default_slot) {
        default_slot.m(svelte_virtual_list_row, null);
      }

      append_dev(svelte_virtual_list_row, t1);
      current = true;
    },
    p: function update(ctx, dirty) {
      if (default_slot && default_slot.p && dirty &
      /*$$scope, visible*/
      262160) {
        default_slot.p(get_slot_context(default_slot_template, ctx,
        /*$$scope*/
        ctx[18], get_default_slot_context), get_slot_changes(default_slot_template,
        /*$$scope*/
        ctx[18], dirty, get_default_slot_changes));
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(svelte_virtual_list_row);
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_each_block.name,
    type: "each",
    source: "(124:4) {#each visible as row (row.index)}",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let svelte_virtual_list_viewport;
  let svelte_virtual_list_contents;
  let each_blocks = [];
  let each_1_lookup = new Map();
  let svelte_virtual_list_viewport_resize_listener;
  let current;
  let dispose;
  let each_value =
  /*visible*/
  ctx[4];

  const get_key = ctx =>
  /*row*/
  ctx[23].index;

  validate_each_keys(ctx, each_value, get_each_context, get_key);

  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  }

  const block = {
    c: function create() {
      svelte_virtual_list_viewport = element("svelte-virtual-list-viewport");
      svelte_virtual_list_contents = element("svelte-virtual-list-contents");

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }

      set_style(svelte_virtual_list_contents, "padding-top",
      /*top*/
      ctx[5] + "px");
      set_style(svelte_virtual_list_contents, "padding-bottom",
      /*bottom*/
      ctx[6] + "px");
      set_custom_element_data(svelte_virtual_list_contents, "class", "svelte-3f07ig");
      add_location(svelte_virtual_list_contents, file, 120, 2, 3393);
      set_style(svelte_virtual_list_viewport, "height",
      /*height*/
      ctx[0]);
      set_custom_element_data(svelte_virtual_list_viewport, "class", "svelte-3f07ig");
      add_render_callback(() =>
      /*svelte_virtual_list_viewport_elementresize_handler*/
      ctx[22].call(svelte_virtual_list_viewport));
      add_location(svelte_virtual_list_viewport, file, 115, 0, 3243);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, svelte_virtual_list_viewport, anchor);
      append_dev(svelte_virtual_list_viewport, svelte_virtual_list_contents);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].m(svelte_virtual_list_contents, null);
      }
      /*svelte_virtual_list_contents_binding*/


      ctx[20](svelte_virtual_list_contents);
      /*svelte_virtual_list_viewport_binding*/

      ctx[21](svelte_virtual_list_viewport);
      svelte_virtual_list_viewport_resize_listener = add_resize_listener(svelte_virtual_list_viewport,
      /*svelte_virtual_list_viewport_elementresize_handler*/
      ctx[22].bind(svelte_virtual_list_viewport));
      current = true;
      dispose = listen_dev(svelte_virtual_list_viewport, "scroll",
      /*handle_scroll*/
      ctx[7], false, false, false);
    },
    p: function update(ctx, [dirty]) {
      const each_value =
      /*visible*/
      ctx[4];
      group_outros();
      validate_each_keys(ctx, each_value, get_each_context, get_key);
      each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, svelte_virtual_list_contents, outro_and_destroy_block, create_each_block, null, get_each_context);
      check_outros();

      if (!current || dirty &
      /*top*/
      32) {
        set_style(svelte_virtual_list_contents, "padding-top",
        /*top*/
        ctx[5] + "px");
      }

      if (!current || dirty &
      /*bottom*/
      64) {
        set_style(svelte_virtual_list_contents, "padding-bottom",
        /*bottom*/
        ctx[6] + "px");
      }

      if (!current || dirty &
      /*height*/
      1) {
        set_style(svelte_virtual_list_viewport, "height",
        /*height*/
        ctx[0]);
      }
    },
    i: function intro(local) {
      if (current) return;

      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }

      current = true;
    },
    o: function outro(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }

      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(svelte_virtual_list_viewport);

      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      /*svelte_virtual_list_contents_binding*/


      ctx[20](null);
      /*svelte_virtual_list_viewport_binding*/

      ctx[21](null);
      svelte_virtual_list_viewport_resize_listener.cancel();
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let {
    items
  } = $$props;
  let {
    height = "100%"
  } = $$props;
  let {
    itemHeight = undefined
  } = $$props;
  let foo;
  let {
    start = 0
  } = $$props;
  let {
    end = 0
  } = $$props; // local state

  let height_map = [];
  let rows;
  let viewport;
  let contents;
  let viewport_height = 0;
  let visible;
  let mounted;
  let top = 0;
  let bottom = 0;
  let average_height;

  async function refresh(items1, viewport_height1, itemHeight1) {
    const {
      scrollTop
    } = viewport;
    await tick(); // wait until the DOM is up to date

    let content_height = top - scrollTop;
    let i = start;

    while (content_height < viewport_height1 && i < items1.length) {
      let row = rows[i - start];

      if (!row) {
        $$invalidate(9, end = i + 1);
        await tick(); // render the newly visible row

        row = rows[i - start];
      }

      const row_height = height_map[i] = itemHeight1 || row.offsetHeight;
      content_height += row_height;
      i += 1;
    }

    $$invalidate(9, end = i);
    const remaining = items1.length - end;
    average_height = (top + content_height) / end;
    $$invalidate(6, bottom = remaining * average_height);
    height_map.length = items1.length;
  }

  async function handle_scroll() {
    const {
      scrollTop
    } = viewport;
    const old_start = start;

    for (let v = 0; v < rows.length; v += 1) {
      height_map[start + v] = itemHeight || rows[v].offsetHeight;
    }

    let i = 0;
    let y = 0;

    while (i < items.length) {
      const row_height = height_map[i] || average_height;

      if (y + row_height > scrollTop) {
        $$invalidate(8, start = i);
        $$invalidate(5, top = y);
        break;
      }

      y += row_height;
      i += 1;
    }

    while (i < items.length) {
      y += height_map[i] || average_height;
      i += 1;
      if (y > scrollTop + viewport_height) break;
    }

    $$invalidate(9, end = i);
    const remaining = items.length - end;
    average_height = y / end;

    while (i < items.length) height_map[i++] = average_height;

    $$invalidate(6, bottom = remaining * average_height); // prevent jumping if we scrolled up into unknown territory

    if (start < old_start) {
      await tick();
      let expected_height = 0;
      let actual_height = 0;

      for (let i1 = start; i1 < old_start; i1 += 1) {
        if (rows[i1 - start]) {
          expected_height += height_map[i1];
          actual_height += itemHeight || rows[i1 - start].offsetHeight;
        }
      }

      const d = actual_height - expected_height;
      viewport.scrollTo(0, scrollTop + d);
    }
  } // trigger initial refresh


  onMount(() => {
    rows = contents.getElementsByTagName("svelte-virtual-list-row");
    $$invalidate(14, mounted = true);
  });
  const writable_props = ["items", "height", "itemHeight", "start", "end"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<VirtualList> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;

  function svelte_virtual_list_contents_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $$invalidate(2, contents = $$value);
    });
  }

  function svelte_virtual_list_viewport_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      $$invalidate(1, viewport = $$value);
    });
  }

  function svelte_virtual_list_viewport_elementresize_handler() {
    viewport_height = this.offsetHeight;
    $$invalidate(3, viewport_height);
  }

  $$self.$set = $$props => {
    if ("items" in $$props) $$invalidate(10, items = $$props.items);
    if ("height" in $$props) $$invalidate(0, height = $$props.height);
    if ("itemHeight" in $$props) $$invalidate(11, itemHeight = $$props.itemHeight);
    if ("start" in $$props) $$invalidate(8, start = $$props.start);
    if ("end" in $$props) $$invalidate(9, end = $$props.end);
    if ("$$scope" in $$props) $$invalidate(18, $$scope = $$props.$$scope);
  };

  $$self.$capture_state = () => {
    return {
      items,
      height,
      itemHeight,
      foo,
      start,
      end,
      height_map,
      rows,
      viewport,
      contents,
      viewport_height,
      visible,
      mounted,
      top,
      bottom,
      average_height
    };
  };

  $$self.$inject_state = $$props => {
    if ("items" in $$props) $$invalidate(10, items = $$props.items);
    if ("height" in $$props) $$invalidate(0, height = $$props.height);
    if ("itemHeight" in $$props) $$invalidate(11, itemHeight = $$props.itemHeight);
    if ("foo" in $$props) foo = $$props.foo;
    if ("start" in $$props) $$invalidate(8, start = $$props.start);
    if ("end" in $$props) $$invalidate(9, end = $$props.end);
    if ("height_map" in $$props) height_map = $$props.height_map;
    if ("rows" in $$props) rows = $$props.rows;
    if ("viewport" in $$props) $$invalidate(1, viewport = $$props.viewport);
    if ("contents" in $$props) $$invalidate(2, contents = $$props.contents);
    if ("viewport_height" in $$props) $$invalidate(3, viewport_height = $$props.viewport_height);
    if ("visible" in $$props) $$invalidate(4, visible = $$props.visible);
    if ("mounted" in $$props) $$invalidate(14, mounted = $$props.mounted);
    if ("top" in $$props) $$invalidate(5, top = $$props.top);
    if ("bottom" in $$props) $$invalidate(6, bottom = $$props.bottom);
    if ("average_height" in $$props) average_height = $$props.average_height;
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*items, start, end*/
    1792) {
      $: $$invalidate(4, visible = items.slice(start, end).map((data, i) => {
        return {
          index: i + start,
          data
        };
      }));
    }

    if ($$self.$$.dirty &
    /*mounted, items, viewport_height, itemHeight*/
    19464) {
      // whenever `items` changes, invalidate the current heightmap
      $: if (mounted) refresh(items, viewport_height, itemHeight);
    }
  };

  return [height, viewport, contents, viewport_height, visible, top, bottom, handle_scroll, start, end, items, itemHeight, height_map, rows, mounted, average_height, foo, refresh, $$scope, $$slots, svelte_virtual_list_contents_binding, svelte_virtual_list_viewport_binding, svelte_virtual_list_viewport_elementresize_handler];
}

class VirtualList extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-3f07ig-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {
      items: 10,
      height: 0,
      itemHeight: 11,
      start: 8,
      end: 9
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "VirtualList",
      options,
      id: create_fragment.name
    });
    const {
      ctx
    } = this.$$;
    const props = options.props || {};

    if (
    /*items*/
    ctx[10] === undefined && !("items" in props)) {
      console.warn("<VirtualList> was created without expected prop 'items'");
    }
  }

  get items() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set items(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get height() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set height(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get itemHeight() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set itemHeight(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get start() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set start(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get end() {
    throw new Error("<VirtualList>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set end(value) {
    throw new Error("<VirtualList>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default VirtualList;