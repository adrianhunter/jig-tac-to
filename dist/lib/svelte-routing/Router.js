/* src/lib/svelte-routing/Router.svelte generated by Svelte v3.18.1 */
import { SvelteComponentDev, component_subscribe, create_slot, dispatch_dev, get_slot_changes, get_slot_context, init, safe_not_equal, transition_in, transition_out, validate_store } from "/web_modules/svelte/internal.js";
import { getContext, setContext, onMount } from "/web_modules/svelte.js";
import { writable, derived } from "/web_modules/svelte/store.js";
import { LOCATION, ROUTER } from "./contexts.js";
import { globalHistory } from "./history.js";
import { pick, match, stripSlashes, combinePaths } from "./utils.js";
const file = "src/lib/svelte-routing/Router.svelte";

function create_fragment(ctx) {
  let current;
  const default_slot_template =
  /*$$slots*/
  ctx[16].default;
  const default_slot = create_slot(default_slot_template, ctx,
  /*$$scope*/
  ctx[15], null);
  const block = {
    c: function create() {
      if (default_slot) default_slot.c();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if (default_slot) {
        default_slot.m(target, anchor);
      }

      current = true;
    },
    p: function update(ctx, [dirty]) {
      if (default_slot && default_slot.p && dirty &
      /*$$scope*/
      32768) {
        default_slot.p(get_slot_context(default_slot_template, ctx,
        /*$$scope*/
        ctx[15], null), get_slot_changes(default_slot_template,
        /*$$scope*/
        ctx[15], dirty, null));
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(default_slot, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (default_slot) default_slot.d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let $base;
  let $location;
  let $routes;
  let {
    basepath = "/"
  } = $$props;
  let {
    url = null
  } = $$props;
  const locationContext = getContext(LOCATION);
  const routerContext = getContext(ROUTER);
  const routes = writable([]);
  validate_store(routes, "routes");
  component_subscribe($$self, routes, value => $$invalidate(8, $routes = value));
  const activeRoute = writable(null);
  let hasActiveRoute = false; // Used in SSR to synchronously set that a Route is active.
  // If locationContext is not set, this is the topmost Router in the tree.
  // If the `url` prop is given we force the location to it.

  const location = locationContext || writable(url ? {
    pathname: url
  } : globalHistory.location);
  validate_store(location, "location");
  component_subscribe($$self, location, value => $$invalidate(7, $location = value)); // If routerContext is set, the routerBase of the parent Router
  // will be the base for this Router's descendants.
  // If routerContext is not set, the path and resolved uri will both
  // have the value of the basepath prop.

  const base = routerContext ? routerContext.routerBase : writable({
    path: basepath,
    uri: basepath
  });
  validate_store(base, "base");
  component_subscribe($$self, base, value => $$invalidate(6, $base = value));
  const routerBase = derived([base, activeRoute], ([base, activeRoute]) => {
    // If there is no activeRoute, the routerBase will be identical to the base.
    if (activeRoute === null) {
      return base;
    }

    const {
      path: basepath
    } = base;
    const {
      route,
      uri
    } = activeRoute; // Remove the potential /* or /*splatname from
    // the end of the child Routes relative paths.

    const path = route.default ? basepath : route.path.replace(/\*.*$/, "");
    return {
      path,
      uri
    };
  });

  function registerRoute(route) {
    const {
      path: basepath
    } = $base;
    let {
      path
    } = route; // We store the original path in the _path property so we can reuse
    // it when the basepath changes. The only thing that matters is that
    // the route reference is intact, so mutation is fine.

    route._path = path;
    route.path = combinePaths(basepath, path);

    if (typeof window === "undefined") {
      // In SSR we should set the activeRoute immediately if it is a match.
      // If there are more Routes being registered after a match is found,
      // we just skip them.
      if (hasActiveRoute) {
        return;
      }

      const matchingRoute = match(route, $location.pathname);

      if (matchingRoute) {
        activeRoute.set(matchingRoute);
        hasActiveRoute = true;
      }
    } else {
      routes.update(rs => {
        rs.push(route);
        return rs;
      });
    }
  }

  function unregisterRoute(route) {
    routes.update(rs => {
      const index = rs.indexOf(route);
      rs.splice(index, 1);
      return rs;
    });
  }

  if (!locationContext) {
    // The topmost Router in the tree is responsible for updating
    // the location store and supplying it through context.
    onMount(() => {
      const unlisten = globalHistory.listen(history => {
        location.set(history.location);
      });
      return unlisten;
    });
    setContext(LOCATION, location);
  }

  setContext(ROUTER, {
    activeRoute,
    base,
    routerBase,
    registerRoute,
    unregisterRoute
  });
  const writable_props = ["basepath", "url"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Router> was created with unknown prop '${key}'`);
  });
  let {
    $$slots = {},
    $$scope
  } = $$props;

  $$self.$set = $$props => {
    if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    if ("url" in $$props) $$invalidate(4, url = $$props.url);
    if ("$$scope" in $$props) $$invalidate(15, $$scope = $$props.$$scope);
  };

  $$self.$capture_state = () => {
    return {
      basepath,
      url,
      hasActiveRoute,
      $base,
      $location,
      $routes
    };
  };

  $$self.$inject_state = $$props => {
    if ("basepath" in $$props) $$invalidate(3, basepath = $$props.basepath);
    if ("url" in $$props) $$invalidate(4, url = $$props.url);
    if ("hasActiveRoute" in $$props) hasActiveRoute = $$props.hasActiveRoute;
    if ("$base" in $$props) base.set($base = $$props.$base);
    if ("$location" in $$props) location.set($location = $$props.$location);
    if ("$routes" in $$props) routes.set($routes = $$props.$routes);
  };

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*$base*/
    64) {
      // This reactive statement will update all the Routes' path when
      // the basepath changes.
      $: {
        const {
          path: basepath
        } = $base;
        routes.update(rs => {
          rs.forEach(r => r.path = combinePaths(basepath, r._path));
          return rs;
        });
      }
    }

    if ($$self.$$.dirty &
    /*$routes, $location*/
    384) {
      // This reactive statement will be run when the Router is created
      // when there are no Routes and then again the following tick, so it
      // will not find an active Route in SSR and in the browser it will only
      // pick an active Route after all Routes have been registered.
      $: {
        const bestMatch = pick($routes, $location.pathname);
        activeRoute.set(bestMatch);
      }
    }
  };

  return [routes, location, base, basepath, url, hasActiveRoute, $base, $location, $routes, locationContext, routerContext, activeRoute, routerBase, registerRoute, unregisterRoute, $$scope, $$slots];
}

class Router extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      basepath: 3,
      url: 4
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Router",
      options,
      id: create_fragment.name
    });
  }

  get basepath() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set basepath(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get url() {
    throw new Error("<Router>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set url(value) {
    throw new Error("<Router>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default Router;