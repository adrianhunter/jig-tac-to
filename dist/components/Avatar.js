/* src/components/Avatar.svelte generated by Svelte v3.18.1 */
import { SvelteComponentDev, add_location, append_dev, attr_dev, detach_dev, dispatch_dev, element, init, insert_dev, noop, safe_not_equal, set_data_dev, space, text } from "/web_modules/svelte/internal.js";
const file = "src/components/Avatar.svelte";

function create_fragment(ctx) {
  let div;
  let img;
  let img_src_value;
  let t0;
  let p;
  let t1_value =
  /*user*/
  ctx[0].name + "";
  let t1;
  const block = {
    c: function create() {
      div = element("div");
      img = element("img");
      t0 = space();
      p = element("p");
      t1 = text(t1_value);
      if (img.src !== (img_src_value =
      /*user*/
      ctx[0].image)) attr_dev(img, "src", img_src_value);
      attr_dev(img, "alt", "");
      add_location(img, file, 5, 2, 47);
      add_location(p, file, 6, 2, 81);
      add_location(div, file, 4, 0, 39);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, img);
      append_dev(div, t0);
      append_dev(div, p);
      append_dev(p, t1);
    },
    p: function update(ctx, [dirty]) {
      if (dirty &
      /*user*/
      1 && img.src !== (img_src_value =
      /*user*/
      ctx[0].image)) {
        attr_dev(img, "src", img_src_value);
      }

      if (dirty &
      /*user*/
      1 && t1_value !== (t1_value =
      /*user*/
      ctx[0].name + "")) set_data_dev(t1, t1_value);
    },
    i: noop,
    o: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let {
    user
  } = $$props;
  const writable_props = ["user"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Avatar> was created with unknown prop '${key}'`);
  });

  $$self.$set = $$props => {
    if ("user" in $$props) $$invalidate(0, user = $$props.user);
  };

  $$self.$capture_state = () => {
    return {
      user
    };
  };

  $$self.$inject_state = $$props => {
    if ("user" in $$props) $$invalidate(0, user = $$props.user);
  };

  return [user];
}

class Avatar extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment, safe_not_equal, {
      user: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Avatar",
      options,
      id: create_fragment.name
    });
    const {
      ctx
    } = this.$$;
    const props = options.props || {};

    if (
    /*user*/
    ctx[0] === undefined && !("user" in props)) {
      console.warn("<Avatar> was created without expected prop 'user'");
    }
  }

  get user() {
    throw new Error("<Avatar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set user(value) {
    throw new Error("<Avatar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default Avatar;