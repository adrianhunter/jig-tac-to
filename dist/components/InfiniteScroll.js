/* src/components/InfiniteScroll.svelte generated by Svelte v3.18.1 */
import { SvelteComponentDev, add_flush_callback, add_location, append_dev, attr_dev, bind, binding_callbacks, create_component, destroy_component, detach_dev, dispatch_dev, element, globals, init, insert_dev, mount_component, safe_not_equal, transition_in, transition_out } from "/web_modules/svelte/internal.js";
const {
  Object: Object_1,
  console: console_1
} = globals;
import VirtualList from "../lib/VirtualList.js";
const file = "src/components/InfiniteScroll.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-14t6p8z-style";
  style.textContent = "div.svelte-14t6p8z{height:100vh}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSW5maW5pdGVTY3JvbGwuc3ZlbHRlIiwic291cmNlcyI6WyJJbmZpbml0ZVNjcm9sbC5zdmVsdGUiXSwic291cmNlc0NvbnRlbnQiOlsiPHNjcmlwdD5cbiAgaW1wb3J0IFZpcnR1YWxMaXN0IGZyb20gXCIuLi9saWIvVmlydHVhbExpc3Quc3ZlbHRlXCI7XG4gIC8vIGltcG9ydCBWaXJ0dWFsTGlzdCBmcm9tIFwiLi9WaXJ0dWFsTGlzdC5zdmVsdGVcIjtcblxuICBleHBvcnQgbGV0IGl0ZW1zO1xuICBleHBvcnQgbGV0IEl0ZW07XG4gICQ6IHJlYWxJdGVtcyA9IFtdO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBpZiAoaXRlbXMuc3Vic2NyaWJlKSB7XG4gICAgaXRlbXMuc3Vic2NyaWJlKHIgPT4gci50aGVuKHVwZGF0ZUl0ZW1zKSk7XG5cbiAgICBjb25zb2xlLmVycm9yKFwibXVzdCBoYXZlIHN1YiBmdW5jdGlvblwiKTtcbiAgfSBlbHNlIHtcbiAgICByZWFsSXRlbXMgPSBpdGVtcztcbiAgfVxuXG4gIGNvbnNvbGUubG9nKFwiaXRlbXNcIiwgaXRlbXMpO1xuXG4gIGxldCBnbG9iYWxOZXh0R3JvdXBLZXkgPSAxO1xuICBsZXQgZ2xvYmFsTmV4dEtleSA9IDA7XG5cbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlSXRlbXMocmVzdWx0KSB7XG4gICAgaWYgKCFyZXN1bHQuZGF0YSkgcmV0dXJuO1xuICAgIC8vIGlmIChpbml0aWFsaXplZCkgcmV0dXJuO1xuXG4gICAgY29uc29sZS5sb2coXCJ1cGRhdGVcIiwgcmVzdWx0KTtcblxuICAgIHJlYWxJdGVtcyA9IFsuLi5yZWFsSXRlbXMsIC4uLnJlc3VsdC5kYXRhW09iamVjdC5rZXlzKHJlc3VsdC5kYXRhKVswXV1dO1xuXG4gICAgLy8gcmVzdWx0LmRhdGEucmV2ZXJzZSgpO1xuICAgIC8vIGNvbnN0IGtleXMgPSByZXN1bHQuZGF0YVtPYmplY3Qua2V5cyhyZXN1bHQuZGF0YSlbMF1dO1xuICAgIC8vIGtleXMucmV2ZXJzZSgpO1xuICAgIC8vIGNvbnN0IGZvbyA9IGtleXMubWFwKChyLCBpKSA9PiB7XG4gICAgLy8gICByLmtleSA9IGdsb2JhbE5leHRLZXkgKyBpO1xuXG4gICAgLy8gICBpZiAoaSA+IDAgJiYgaSAlIGxpbWl0ID09IDApIHtcbiAgICAvLyAgICAgZ2xvYmFsTmV4dEdyb3VwS2V5Kys7XG4gICAgLy8gICB9XG5cbiAgICAvLyAgIHIuZ3JvdXBLZXkgPSBnbG9iYWxOZXh0R3JvdXBLZXk7XG5cbiAgICAvLyAgIHJldHVybiByO1xuICAgIC8vIH0pO1xuICAgIC8vIGxvYWRpbmcgPSBmYWxzZTtcbiAgICAvLyBjb25zb2xlLmxvZyhcImZvb2Zvb2Zvb2Zvb1wiLCBmb28pO1xuICAgIC8vIC8vIGlnLmdldEluc3RhbmNlKCkuY2xlYXIoKTtcbiAgICAvLyByZWFsSXRlbXMgPSBbLi4ucmVhbEl0ZW1zLCAuLi5mb29dO1xuICB9XG5cbiAgbGV0IHN0YXJ0O1xuICBsZXQgZW5kO1xuXG4gIGxldCB0aW1lb3V0O1xuXG4gICQ6IGNvbnNvbGUubG9nKFwicmVhbEl0ZW1zXCIsIHJlYWxJdGVtcyk7XG5cbiAgJDogaWYgKGVuZCA+IHJlYWxJdGVtcy5sZW5ndGggLSAxMykge1xuICAgIG9mZnNldCArPSAzMDtcblxuICAgIGlmICh0aW1lb3V0KSBjbGVhclRpbWVvdXQodGltZW91dCk7XG5cbiAgICB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjb25zb2xlLmxvZyhcInJlZmV0Y2hcIik7XG5cbiAgICAgIGl0ZW1zLmZldGNoTW9yZSh7XG4gICAgICAgIHZhcmlhYmxlczoge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9XG4gICAgICAgIC8vIHVwZGF0ZVF1ZXJ5OiAocHJldiwgeyBmZXRjaE1vcmVSZXN1bHQgfSkgPT4ge1xuICAgICAgICAvLyAgIGlmICghZmV0Y2hNb3JlUmVzdWx0KSByZXR1cm4gcHJldjtcbiAgICAgICAgLy8gICBjb25zdCBmaXJzdEtleSA9IE9iamVjdC5rZXlzKHByZXYpWzBdO1xuICAgICAgICAvLyAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICAvLyAgIG9ialtmaXJzdEtleV0gPSBbLi4ucHJldltmaXJzdEtleV0sIC4uLmZldGNoTW9yZVJlc3VsdFtmaXJzdEtleV1dO1xuICAgICAgICAvLyAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcmV2LCBvYmopO1xuICAgICAgICAvLyB9XG4gICAgICB9KTtcbiAgICB9LCAzMDApO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBkaXYge1xuICAgIGhlaWdodDogMTAwdmg7XG4gIH1cbjwvc3R5bGU+XG5cbjxkaXY+XG4gIDxWaXJ0dWFsTGlzdCBpdGVtcz17cmVhbEl0ZW1zfSBiaW5kOnN0YXJ0IGJpbmQ6ZW5kIGxldDppdGVtPlxuXG4gICAgPEl0ZW0ge2l0ZW19IC8+XG5cbiAgICA8IS0tIDxzbG90IHtpdGVtfT5cbiAgICAgIDxkaXY+bm90IGl0ZW0gc2xvdDwvZGl2PlxuXG4gICAgICB7I2lmIEl0ZW19XG4gICAgICB7OmVsc2V9XG4gICAgICB7L2lmfVxuICAgIDwvc2xvdD4gLS0+XG4gIDwvVmlydHVhbExpc3Q+XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFrRkUsR0FBRyxlQUFDLENBQUMsQUFDSCxNQUFNLENBQUUsS0FBSyxBQUNmLENBQUMifQ== */";
  append_dev(document.head, style);
} // (89:2) <VirtualList items={realItems} bind:start bind:end let:item>


function create_default_slot(ctx) {
  let current;
  const item = new
  /*Item*/
  ctx[0]({
    props: {
      item:
      /*item*/
      ctx[12]
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(item.$$.fragment);
    },
    m: function mount(target, anchor) {
      mount_component(item, target, anchor);
      current = true;
    },
    p: function update(ctx, dirty) {
      const item_changes = {};
      if (dirty &
      /*item*/
      4096) item_changes.item =
      /*item*/
      ctx[12];
      item.$set(item_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(item.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(item.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(item, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(89:2) <VirtualList items={realItems} bind:start bind:end let:item>",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let div;
  let updating_start;
  let updating_end;
  let current;

  function virtuallist_start_binding(value) {
    /*virtuallist_start_binding*/
    ctx[10].call(null, value);
  }

  function virtuallist_end_binding(value_1) {
    /*virtuallist_end_binding*/
    ctx[11].call(null, value_1);
  }

  let virtuallist_props = {
    items:
    /*realItems*/
    ctx[3],
    $$slots: {
      default: [create_default_slot, ({
        item
      }) => ({
        12: item
      }), ({
        item
      }) => item ? 4096 : 0]
    },
    $$scope: {
      ctx
    }
  };

  if (
  /*start*/
  ctx[1] !== void 0) {
    virtuallist_props.start =
    /*start*/
    ctx[1];
  }

  if (
  /*end*/
  ctx[2] !== void 0) {
    virtuallist_props.end =
    /*end*/
    ctx[2];
  }

  const virtuallist = new VirtualList({
    props: virtuallist_props,
    $$inline: true
  });
  binding_callbacks.push(() => bind(virtuallist, "start", virtuallist_start_binding));
  binding_callbacks.push(() => bind(virtuallist, "end", virtuallist_end_binding));
  const block = {
    c: function create() {
      div = element("div");
      create_component(virtuallist.$$.fragment);
      attr_dev(div, "class", "svelte-14t6p8z");
      add_location(div, file, 87, 0, 1893);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      mount_component(virtuallist, div, null);
      current = true;
    },
    p: function update(ctx, [dirty]) {
      const virtuallist_changes = {};
      if (dirty &
      /*realItems*/
      8) virtuallist_changes.items =
      /*realItems*/
      ctx[3];

      if (dirty &
      /*$$scope, item*/
      12288) {
        virtuallist_changes.$$scope = {
          dirty,
          ctx
        };
      }

      if (!updating_start && dirty &
      /*start*/
      2) {
        updating_start = true;
        virtuallist_changes.start =
        /*start*/
        ctx[1];
        add_flush_callback(() => updating_start = false);
      }

      if (!updating_end && dirty &
      /*end*/
      4) {
        updating_end = true;
        virtuallist_changes.end =
        /*end*/
        ctx[2];
        add_flush_callback(() => updating_end = false);
      }

      virtuallist.$set(virtuallist_changes);
    },
    i: function intro(local) {
      if (current) return;
      transition_in(virtuallist.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(virtuallist.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      destroy_component(virtuallist);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function instance($$self, $$props, $$invalidate) {
  let {
    items
  } = $$props;
  let {
    Item
  } = $$props;
  let offset = 0;

  if (items.subscribe) {
    items.subscribe(r => r.then(updateItems));
    console.error("must have sub function");
  } else {
    realItems = items;
  }

  console.log("items", items);
  let globalNextGroupKey = 1;
  let globalNextKey = 0;

  async function updateItems(result) {
    if (!result.data) return; // if (initialized) return;

    console.log("update", result);
    $$invalidate(3, realItems = [...realItems, ...result.data[Object.keys(result.data)[0]]]);
  } // result.data.reverse();
  // const keys = result.data[Object.keys(result.data)[0]];
  // keys.reverse();
  // const foo = keys.map((r, i) => {
  //   r.key = globalNextKey + i;
  //   if (i > 0 && i % limit == 0) {
  //     globalNextGroupKey++;
  //   }
  //   r.groupKey = globalNextGroupKey;
  //   return r;
  // });
  // loading = false;
  // console.log("foofoofoofoo", foo);
  // // ig.getInstance().clear();
  // realItems = [...realItems, ...foo];


  let start;
  let end;
  let timeout;
  const writable_props = ["items", "Item"];
  Object_1.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<InfiniteScroll> was created with unknown prop '${key}'`);
  });

  function virtuallist_start_binding(value) {
    start = value;
    $$invalidate(1, start);
  }

  function virtuallist_end_binding(value_1) {
    end = value_1;
    $$invalidate(2, end);
  }

  $$self.$set = $$props => {
    if ("items" in $$props) $$invalidate(4, items = $$props.items);
    if ("Item" in $$props) $$invalidate(0, Item = $$props.Item);
  };

  $$self.$capture_state = () => {
    return {
      items,
      Item,
      offset,
      globalNextGroupKey,
      globalNextKey,
      start,
      end,
      timeout,
      realItems
    };
  };

  $$self.$inject_state = $$props => {
    if ("items" in $$props) $$invalidate(4, items = $$props.items);
    if ("Item" in $$props) $$invalidate(0, Item = $$props.Item);
    if ("offset" in $$props) $$invalidate(5, offset = $$props.offset);
    if ("globalNextGroupKey" in $$props) globalNextGroupKey = $$props.globalNextGroupKey;
    if ("globalNextKey" in $$props) globalNextKey = $$props.globalNextKey;
    if ("start" in $$props) $$invalidate(1, start = $$props.start);
    if ("end" in $$props) $$invalidate(2, end = $$props.end);
    if ("timeout" in $$props) $$invalidate(6, timeout = $$props.timeout);
    if ("realItems" in $$props) $$invalidate(3, realItems = $$props.realItems);
  };

  let realItems;

  $$self.$$.update = () => {
    if ($$self.$$.dirty &
    /*realItems*/
    8) {
      $: console.log("realItems", realItems);
    }

    if ($$self.$$.dirty &
    /*end, realItems, offset, timeout, items*/
    124) {
      $: if (end > realItems.length - 13) {
        $$invalidate(5, offset += 30);
        if (timeout) clearTimeout(timeout);
        $$invalidate(6, timeout = setTimeout(() => {
          console.log("refetch"); //   const obj = {};
          //   obj[firstKey] = [...prev[firstKey], ...fetchMoreResult[firstKey]];

          items.fetchMore({
            variables: {
              offset
            }
          }); // updateQuery: (prev, { fetchMoreResult }) => {
          //   if (!fetchMoreResult) return prev;
          //   const firstKey = Object.keys(prev)[0];
        }, //   return Object.assign({}, prev, obj);
        // }
        300)); //   const obj = {};
        //   obj[firstKey] = [...prev[firstKey], ...fetchMoreResult[firstKey]];
      }
    }
  };

  $: $$invalidate(3, realItems = []);

  return [Item, start, end, realItems, items, offset, timeout, globalNextGroupKey, globalNextKey, updateItems, virtuallist_start_binding, virtuallist_end_binding];
}

class InfiniteScroll extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-14t6p8z-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {
      items: 4,
      Item: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "InfiniteScroll",
      options,
      id: create_fragment.name
    });
    const {
      ctx
    } = this.$$;
    const props = options.props || {};

    if (
    /*items*/
    ctx[4] === undefined && !("items" in props)) {
      console_1.warn("<InfiniteScroll> was created without expected prop 'items'");
    }

    if (
    /*Item*/
    ctx[0] === undefined && !("Item" in props)) {
      console_1.warn("<InfiniteScroll> was created without expected prop 'Item'");
    }
  }

  get items() {
    throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set items(value) {
    throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  get Item() {
    throw new Error("<InfiniteScroll>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set Item(value) {
    throw new Error("<InfiniteScroll>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default InfiniteScroll;