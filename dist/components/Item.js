/* src/components/Item.svelte generated by Svelte v3.18.1 */
import { SvelteComponentDev, add_location, append_dev, attr_dev, create_component, destroy_component, detach_dev, dispatch_dev, element, globals, init, insert_dev, listen_dev, mount_component, noop, prevent_default, safe_not_equal, set_data_dev, space, text, transition_in, transition_out } from "/web_modules/svelte/internal.js";
const {
  console: console_1
} = globals;
import Avatar from "./Avatar.js";
import { Card } from "/web_modules/smelte.js";
import { onMount } from "/web_modules/svelte.js";
const file = "src/components/Item.svelte";

function add_css() {
  var style = element("style");
  style.id = "svelte-qkcvvl-style";
  style.textContent = "div.svelte-qkcvvl{width:650px;word-break:break-word;margin:0 auto}@media(min-width: 480){}@media(max-width: 480px){.content.svelte-qkcvvl{width:100%}}\n/*# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiSXRlbS5zdmVsdGUiLCJzb3VyY2VzIjpbIkl0ZW0uc3ZlbHRlIl0sInNvdXJjZXNDb250ZW50IjpbIjxzY3JpcHQ+XG4gIGltcG9ydCBBdmF0YXIgZnJvbSBcIi4vQXZhdGFyLnN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBDYXJkIH0gZnJvbSBcInNtZWx0ZVwiO1xuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBleHBvcnQgbGV0IGl0ZW07XG5cbiAgLy8gb25Nb3VudCgoKSA9PiB7XG4gIC8vICAgaWYgKG1lYXN1cmUpIHtcbiAgLy8gICAgIGNvbnNvbGUubG9nKFwiTUVBU1VSRVwiKTtcbiAgLy8gICAgIG1lYXN1cmUoKTtcbiAgLy8gICB9XG4gIC8vIH0pO1xuXG4gIGZ1bmN0aW9uIGhhbmRsZUxpa2UoZSkge1xuICAgIGNvbnNvbGUubG9nKGUpO1xuICB9XG48L3NjcmlwdD5cblxuPHN0eWxlPlxuICBkaXYge1xuICAgIHdpZHRoOiA2NTBweDtcbiAgICB3b3JkLWJyZWFrOiBicmVhay13b3JkO1xuICAgIG1hcmdpbjogMCBhdXRvO1xuICB9XG4gIC8qIC5jb250YWluZXIgYSAuaXRlbSB7XG4gICAgd2lkdGg6IDEwMCU7XG4gIH0gKi9cblxuICBAbWVkaWEgKG1pbi13aWR0aDogNDgwKSB7XG4gICAgLml0ZW0ge1xuICAgICAgd2lkdGg6IDYwMHB4O1xuICAgIH1cbiAgfVxuICBAbWVkaWEgKG1heC13aWR0aDogNDgwcHgpIHtcbiAgICAuY29udGVudCB7XG4gICAgICB3aWR0aDogMTAwJTtcbiAgICB9XG4gICAgLml0ZW0ge1xuICAgICAgd2lkdGg6IDEwMCU7XG4gICAgfVxuICB9XG48L3N0eWxlPlxuXG48ZGl2PlxuICA8YSBocmVmPVwiL3R4L3tpdGVtLnR4SGFzaH1cIj5cbiAgICA8Q2FyZC5DYXJkIGNsYXNzPVwiaXRlbVwiPlxuICAgICAgPGRpdiBzbG90PVwidGl0bGVcIiAvPlxuICAgICAgPGRpdiBzbG90PVwibWVkaWFcIiAvPlxuICAgICAgPGRpdiBzbG90PVwidGV4dFwiIGNsYXNzPVwiY29udGVudCBwLTUgcGItMCBwdC0zIHRleHQtZ3JheS03MDAgYm9keS0yXCI+XG4gICAgICAgIHtKU09OLnN0cmluZ2lmeShpdGVtLCBudWxsLCAyKX1cbiAgICAgIDwvZGl2PlxuICAgICAgPGRpdiBzbG90PVwiYWN0aW9uc1wiPlxuICAgICAgICA8ZGl2IGNsYXNzPVwicC0yXCI+XG5cbiAgICAgICAgICA8YnV0dG9uIHRleHQgb246Y2xpY2t8cHJldmVudERlZmF1bHQ9e2hhbmRsZUxpa2V9Pmxpa2U8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cbiAgICA8L0NhcmQuQ2FyZD5cblxuICA8L2E+XG48L2Rpdj5cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtQkUsR0FBRyxjQUFDLENBQUMsQUFDSCxLQUFLLENBQUUsS0FBSyxDQUNaLFVBQVUsQ0FBRSxVQUFVLENBQ3RCLE1BQU0sQ0FBRSxDQUFDLENBQUMsSUFBSSxBQUNoQixDQUFDLEFBS0QsTUFBTSxBQUFDLFlBQVksR0FBRyxDQUFDLEFBQUMsQ0FBQyxBQUl6QixDQUFDLEFBQ0QsTUFBTSxBQUFDLFlBQVksS0FBSyxDQUFDLEFBQUMsQ0FBQyxBQUN6QixRQUFRLGNBQUMsQ0FBQyxBQUNSLEtBQUssQ0FBRSxJQUFJLEFBQ2IsQ0FBQyxBQUlILENBQUMifQ== */";
  append_dev(document.head, style);
} // (47:6) 


function create_title_slot(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "slot", "title");
      attr_dev(div, "class", "svelte-qkcvvl");
      add_location(div, file, 46, 6, 715);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_title_slot.name,
    type: "slot",
    source: "(47:6) ",
    ctx
  });
  return block;
} // (48:6) 


function create_media_slot(ctx) {
  let div;
  const block = {
    c: function create() {
      div = element("div");
      attr_dev(div, "slot", "media");
      attr_dev(div, "class", "svelte-qkcvvl");
      add_location(div, file, 47, 6, 742);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_media_slot.name,
    type: "slot",
    source: "(48:6) ",
    ctx
  });
  return block;
} // (49:6) <div slot="text" class="content p-5 pb-0 pt-3 text-gray-700 body-2">


function create_text_slot(ctx) {
  let div;
  let t_value = JSON.stringify(
  /*item*/
  ctx[0], null, 2) + "";
  let t;
  const block = {
    c: function create() {
      div = element("div");
      t = text(t_value);
      attr_dev(div, "slot", "text");
      attr_dev(div, "class", "content p-5 pb-0 pt-3 text-gray-700 body-2 svelte-qkcvvl");
      add_location(div, file, 48, 6, 769);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, t);
    },
    p: function update(ctx, dirty) {
      if (dirty &
      /*item*/
      1 && t_value !== (t_value = JSON.stringify(
      /*item*/
      ctx[0], null, 2) + "")) set_data_dev(t, t_value);
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_text_slot.name,
    type: "slot",
    source: "(49:6) <div slot=\\\"text\\\" class=\\\"content p-5 pb-0 pt-3 text-gray-700 body-2\\\">",
    ctx
  });
  return block;
} // (52:6) <div slot="actions">


function create_actions_slot(ctx) {
  let div0;
  let div1;
  let button;
  let dispose;
  const block = {
    c: function create() {
      div0 = element("div");
      div1 = element("div");
      button = element("button");
      button.textContent = "like";
      attr_dev(button, "text", "");
      add_location(button, file, 54, 10, 955);
      attr_dev(div1, "class", "p-2 svelte-qkcvvl");
      add_location(div1, file, 52, 8, 926);
      attr_dev(div0, "slot", "actions");
      attr_dev(div0, "class", "svelte-qkcvvl");
      add_location(div0, file, 51, 6, 897);
    },
    m: function mount(target, anchor) {
      insert_dev(target, div0, anchor);
      append_dev(div0, div1);
      append_dev(div1, button);
      dispose = listen_dev(button, "click", prevent_default(handleLike), false, true, false);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(div0);
      dispose();
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_actions_slot.name,
    type: "slot",
    source: "(52:6) <div slot=\\\"actions\\\">",
    ctx
  });
  return block;
} // (46:4) <Card.Card class="item">


function create_default_slot(ctx) {
  let t0;
  let t1;
  let t2;
  const block = {
    c: function create() {
      t0 = space();
      t1 = space();
      t2 = space();
    },
    m: function mount(target, anchor) {
      insert_dev(target, t0, anchor);
      insert_dev(target, t1, anchor);
      insert_dev(target, t2, anchor);
    },
    p: noop,
    d: function destroy(detaching) {
      if (detaching) detach_dev(t0);
      if (detaching) detach_dev(t1);
      if (detaching) detach_dev(t2);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(46:4) <Card.Card class=\\\"item\\\">",
    ctx
  });
  return block;
}

function create_fragment(ctx) {
  let div;
  let a;
  let a_href_value;
  let current;
  const card_card = new Card.Card({
    props: {
      class: "item",
      $$slots: {
        default: [create_default_slot],
        actions: [create_actions_slot],
        text: [create_text_slot],
        media: [create_media_slot],
        title: [create_title_slot]
      },
      $$scope: {
        ctx
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      div = element("div");
      a = element("a");
      create_component(card_card.$$.fragment);
      attr_dev(a, "href", a_href_value = "/tx/" +
      /*item*/
      ctx[0].txHash);
      add_location(a, file, 44, 2, 651);
      attr_dev(div, "class", "svelte-qkcvvl");
      add_location(div, file, 43, 0, 643);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      insert_dev(target, div, anchor);
      append_dev(div, a);
      mount_component(card_card, a, null);
      current = true;
    },
    p: function update(ctx, [dirty]) {
      const card_card_changes = {};

      if (dirty &
      /*$$scope, item*/
      3) {
        card_card_changes.$$scope = {
          dirty,
          ctx
        };
      }

      card_card.$set(card_card_changes);

      if (!current || dirty &
      /*item*/
      1 && a_href_value !== (a_href_value = "/tx/" +
      /*item*/
      ctx[0].txHash)) {
        attr_dev(a, "href", a_href_value);
      }
    },
    i: function intro(local) {
      if (current) return;
      transition_in(card_card.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(card_card.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) detach_dev(div);
      destroy_component(card_card);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}

function handleLike(e) {
  console.log(e);
}

function instance($$self, $$props, $$invalidate) {
  let {
    item
  } = $$props;
  const writable_props = ["item"];
  Object.keys($$props).forEach(key => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console_1.warn(`<Item> was created with unknown prop '${key}'`);
  });

  $$self.$set = $$props => {
    if ("item" in $$props) $$invalidate(0, item = $$props.item);
  };

  $$self.$capture_state = () => {
    return {
      item
    };
  };

  $$self.$inject_state = $$props => {
    if ("item" in $$props) $$invalidate(0, item = $$props.item);
  };

  return [item];
}

class Item extends SvelteComponentDev {
  constructor(options) {
    super(options);
    if (!document.getElementById("svelte-qkcvvl-style")) add_css();
    init(this, options, instance, create_fragment, safe_not_equal, {
      item: 0
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "Item",
      options,
      id: create_fragment.name
    });
    const {
      ctx
    } = this.$$;
    const props = options.props || {};

    if (
    /*item*/
    ctx[0] === undefined && !("item" in props)) {
      console_1.warn("<Item> was created without expected prop 'item'");
    }
  }

  get item() {
    throw new Error("<Item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

  set item(value) {
    throw new Error("<Item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }

}

export default Item;